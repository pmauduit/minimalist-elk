input {
  tcp {
    port  => 9000
    codec => line
  }
}

filter {
  # 1. Initial Parse (The Grok we built)
  grok {
    match => { "message" => "%{IPORHOST:client_ip}\s+%{NOTSPACE:ident}\s+%{NOTSPACE:auth}\s+\[%{HTTPDATE:timestamp}\]\s+\"%{WORD:method}\s+%{NOTSPACE:request_uri}\s+HTTP/%{NUMBER:http_version}\"\s+%{NUMBER:status}\s+%{NUMBER:bytes_sent}\s+\"%{DATA:referrer}\"\s+\"%{DATA:user_agent}\"\s+%{NUMBER:request_length}\s+%{NUMBER:request_time}\s+\[%{DATA:upstream_name}\]\s+\[%{DATA:upstream_locate}?\]\s+%{IPORHOST:upstream_addr}:%{NUMBER:upstream_port}\s+%{NUMBER:upstream_bytes_received}\s+%{NUMBER:upstream_response_time}\s+%{NUMBER:upstream_status}\s+%{WORD:trace_id}" }
  }

  # 2. Extract WMS Parameters (The KV Magic)
  # This targets the request_uri and splits it into fields like 'LAYERS' and 'FORMAT'
  if "/geoserver/ows" in [request_uri] {
    kv {
      source => "request_uri"
      field_split => "&?"
      target => "wms_params"
      include_keys => [ "LAYERS", "SERVICE", "REQUEST", "FORMAT", "BBOX", "SRS", "CRS" ]
    }
  }

  # 3. Clean up and Type Conversion
  mutate {
    convert => {
      "request_time" => "float"
      "upstream_response_time" => "float"
      "bytes_sent" => "integer"
    }
  }

  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }
}


output {
  elasticsearch { hosts => ["elastic:9200"] }
  stdout { codec => rubydebug }
}
